#!/usr/bin/env python3

import requests
import os
import re
import json
import sys
import time
from subprocess import PIPE, Popen, TimeoutExpired
from subprocess import CalledProcessError, check_output
from pymacaroons import Macaroon


UPLOAD_URL = 'https://upload.apps.ubuntu.com/unscanned-upload/'
PUSH_URL = 'https://myapps.developer.ubuntu.com/dev/api/snap-push/'
RELEASE_URL = 'https://myapps.developer.ubuntu.com/dev/api/snap-release/'

REFRESH_URL = 'https://login.ubuntu.com/api/v2/tokens/refresh'

SNAP_NAME = 'cassandra'
SNAP_SERIES = '16'
SNAP_CHANNELS = ['beta']


class StoreException(Exception):
    pass


def post(url, **kwargs):
    '''POST to the specified URL.

    :return: json response object on success, None on error.
    :raises: StoreException on error
    '''
    req = requests.request('POST', url, **kwargs)
    if req.status_code < 200 or req.status_code >= 300:
        message = 'Got {} on {}:\n{}'.format(req.status_code, url, req.text)
        raise StoreException(message)
    else:
        return req.json()


def wait_for_revision(details_url, tries=10, sleep=30):
    '''Wait for the store to give a revision for the upload.

    :return: The positive revision integer on success
    :raises: StoreException on error
    '''
    data = '<no request>'
    for _ in range(tries):
        req = requests.request('GET', details_url)
        data = req.json()
        if data.get('processed', False):
            if data.get('can_release', False):
                return data['revision']
            else:
                message = 'Could not get a revision for the upload.'
                raise StoreException(message)
        time.sleep(sleep)

    message = 'Timed out after waiting {} seconds for revision on {}:\n{}'
    message = message.format(tries * sleep, details_url, data)
    raise StoreException(message)


def print_channel_map(channel_map):
    '''Print a channel map, e.g.:

    Channel    Revision
    stable     -
    candidate  5
    beta       ^
    edge       ^
    '''
    # Longest string plus two characters.
    column = max(len(c.get('channel', '')) for c in channel_map) + 2

    if channel_map:
        padding = ' ' * (column - len('Channel'))
        print('Channel{}Revision'.format(padding))

    for channel in channel_map:
        padding = ' ' * (column - len(channel['channel']))
        print(channel['channel'], end=padding)
        if 'revision' in channel:
            print(channel['revision'])
        else:
            print('^' if channel.get('info') == 'tracking' else '-')


def get_auth_macaroon():
    '''Returns the decrypted value of the AUTH_MACAROON environment variable.

    AUTH_MACAROON is of the form:

    root_mac = Macaroon.deserialize(root)
    discharge_mac = Macaroon.deserialize(discharge)
    bound = root_mac.prepare_for_request(discharge_mac)
    auth = 'Macaroon root={}, discharge={}'.format(root, bound.serialize())
    os.environ['AUTH_MACAROON'] = auth
    '''

    if 'MACAROON_SECRET' not in os.environ:
        raise RuntimeError('MACAROON_SECRET not set in the environment.')
    if 'AUTH_MACAROON' not in os.environ:
        raise RuntimeError('AUTH_MACAROON not set in the environment.')

    cmd = ['openssl', 'enc', '-aes-256-cbc', '-base64', '-d', '-pass',
           'env:MACAROON_SECRET']
    try:
        p = Popen(cmd, stdin=PIPE, stdout=PIPE, universal_newlines=True)
        out, _ = p.communicate(input=os.environ['AUTH_MACAROON'])
    except TimeoutExpired:
        p.kill()
    if p.returncode or not out:
        raise RuntimeError('Could not decrypt macaroon.')
    return out.strip('\n')


def get_snap_file():
    '''Finds the first snap file in the current working directory.
    :return: string of a snap basename
    :raises: RuntimeError if no snaps are found
    '''
    snap_file = [x for x in os.listdir('.') if x.endswith('.snap')]
    if not snap_file:
        raise RuntimeError('No snap files in current directory.')
    else:
        return snap_file[0]


def upload_snap(snap_file):
    '''Upload the snap binary to the Store.'''

    headers = {'Accept': 'application/json'}
    files = {'binary': open(snap_file, 'rb')}
    return post(UPLOAD_URL, headers=headers, files=files)['upload_id']


def notify_store_of_upload(upload_id, auth_macaroon):
    '''Tell the Store of the completed upload.'''

    headers = {'Content-Type': 'application/json',
               'Accept':'application/json',
               'Authorization': auth_macaroon}

    data = {'updown_id': upload_id,
            'name': SNAP_NAME,
            'series': SNAP_SERIES}
    result = post(PUSH_URL, headers=headers, data=json.dumps(data))
    return result['status_details_url']


def publish_snap(revision, auth_macaroon):
    '''Publish the snap to SNAP_CHANNELS in SNAP_SERIES.'''

    headers = {'Content-Type': 'application/json',
               'Accept':'application/json',
               'Authorization': auth_macaroon}

    data = {'name': SNAP_NAME,
            'revision': revision,
            'channels': SNAP_CHANNELS,
            'series': SNAP_SERIES}
    result = post(RELEASE_URL, headers=headers, data=json.dumps(data))
    if not result.get('success'):
        raise StoreException('Could not publish.')

    return result


def cached_macaroon():
    if 'MACAROON_SECRET' not in os.environ:
        raise RuntimeError('MACAROON_SECRET not set in the environment.')
    path = os.path.join(os.path.expanduser('~'), '.macaroon.enc')
    if not os.path.exists(path):
        return None

    cmd = ['openssl', 'enc', '-aes-256-cbc', '-base64', '-d', '-pass',
           'env:MACAROON_SECRET', '-in', path]
    try:
        return check_output(cmd, universal_newlines=True).strip('\n')
    except CalledProcessError:
        raise RuntimeError('Could not decrypt macaroon.')


def save_macaroon(macaroon):
    '''Encrypts the provided macaroon using AES-256 with the secret from
    MACAROON_SECRET. Writes the encrypted macaroon to ~/.macaroon.enc
    '''
    if 'MACAROON_SECRET' not in os.environ:
        raise RuntimeError('MACAROON_SECRET not set in the environment.')

    path = os.path.join(os.path.expanduser('~'), '.macaroon.enc')
    cmd = ['openssl', 'enc', '-aes-256-cbc', '-pass', 'env:MACAROON_SECRET',
           '-base64', '-out', path]
    try:
        p = Popen(cmd, stdin=PIPE, universal_newlines=True)
        p.communicate(input=macaroon)
    except TimeoutExpired:
        p.kill()

    if p.returncode:
        raise RuntimeError('Could not encrypt macaroon.')


def refresh_macaroon(macaroon):
    fmt = 'Macaroon root=([a-zA-Z0-9_-]+), discharge=([a-zA-Z0-9_-]+)'
    root, discharge = re.match(fmt, macaroon).groups()
    data = {'discharge_macaroon': discharge}
    headers = {'Content-Type': 'application/json',
               'Accept':'application/json'}
    result = post(REFRESH_URL, headers=headers, data=json.dumps(data))
    discharge = result['discharge_macaroon']

    root_macaroon = Macaroon.deserialise(root)
    discharge_macaroon = Macaroon.deserialize(discharge)
    bound = root_macaroon.prepare_for_request(discharge_macaroon)
    discharge = bound.serialize()
    return 'Macaroon root={}, discharge={}'.format(root, discharge)


def main():
    try:
        macaroon = cached_macaroon()
        if not macaroon:
            macaroon = get_auth_macaroon()
        #macaroon = refresh_macaroon(macaroon)
        save_macaroon(macaroon)

        snap_file = get_snap_file()
        upload_id = upload_snap(snap_file)
        # TODO need to handle possible refresh needed
        status_url = notify_store_of_upload(upload_id, macaroon)
        revision = wait_for_revision(status_url)
        print('Revision {} of {} created.'.format(revision, SNAP_NAME))
        print()
        # TODO need to handle possible refresh needed
        result = publish_snap(revision, macaroon)
        print_channel_map(result.get('channel_map', []))
        return 0
    except (StoreException, RuntimeError) as e:
        print('Error: {}'.format(e), file=sys.stderr)
        return 1


if __name__ == '__main__':
    sys.exit(main())
